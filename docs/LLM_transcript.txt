## Student Name:
## Student ID: 

Prompt 1: "why am i gettingthis error  File "/cs/home/ainaz04/LAB5 4312/EECS4312_Lab5_SpecificationLab_B_219644350/src/test_solution.py", line 12, in <module>
    import pytest
ModuleNotFoundError: No module named 'pytest'"
LLM Response 1: "Run this in your terminal:

pip install pytest

If that doesn‚Äôt work, try (safer):

python3 -m pip install pytest

or (on some systems):

python -m pip install pytest"

--------------------------------------------------
Prompt 2: "this is my solution but there is a bug here and it's incomplete:def is_allocation_feasible( resources: Dict[str, Number], requests: List[Dict[str, Number]] ) -> bool: # Validate requests structure for req in requests: if not isinstance(req, dict): raise ValueError("Each request must be a dictionary") # Check for unknown resources in requests for req in requests: for resource in req: if resource not in resources: return False # Check capacity constraints for resource, capacity in resources.items(): total_required = sum(req.get(resource, 0) for req in requests) if total_required > capacity: return False return True"
LLM Response 2: "1. Your docstring is in the wrong place (bug)

This part:

    return True

    """
    Determine whether a set of resource requests can be satisfied given limited capacities.


Everything after return True is dead code and never runs.
That triple-quoted string should be at the top of the function, not after return.

üî¥ 2. It‚Äôs logically incomplete (missing important constraints)

Right now, your function:
‚úÖ checks unknown resources
‚úÖ checks total capacity
‚ùå does NOT check:

negative capacities

negative request amounts

non-numeric values

invalid request structure properly"
--------------------------------------------------
--------------------------------------------------
Prompt 3: "provide 6 acceptance criteria  given when then, to cover cases"
LLM Response 2: "Nice, this function is perfect for **Given‚ÄìWhen‚ÄìThen** style acceptance criteria. Here are **6 solid acceptance criteria** that cover the important cases (normal + edge cases + errors):

---

### ‚úÖ 1. Feasible allocation (happy path)

**Given** resource capacities `{cpu: 10, ram: 32}`
**And** requests `[{cpu: 4, ram: 8}, {cpu: 6, ram: 16}]`
**When** `is_allocation_feasible` is called
**Then** the function returns `True`

---

### ‚ùå 2. Total request exceeds capacity

**Given** resource capacities `{cpu: 8, ram: 16}`
**And** requests `[{cpu: 4, ram: 8}, {cpu: 6, ram: 10}]`
**When** `is_allocation_feasible` is called
**Then** the function returns `False`

---

### ‚ùå 3. Request contains unknown resource

**Given** resource capacities `{cpu: 10}`
**And** requests `[{cpu: 4}, {gpu: 2}]`
**When** `is_allocation_feasible` is called
**Then** the function returns `False`

---

### ‚ùå 4. Request contains negative amount

**Given** resource capacities `{cpu: 10}`
**And** requests `[{cpu: -3}]`
**When** `is_allocation_feasible` is called
**Then** the function returns `False`

---

### ‚ùå 5. Resource capacity is invalid (negative)

**Given** resource capacities `{cpu: -5}`
**And** requests `[{cpu: 2}]`
**When** `is_allocation_feasible` is called
**Then** the function returns `False`

---

### ‚ùå 6. Request is not a dictionary

**Given** resource capacities `{cpu: 10}`
**And** requests `[["cpu", 3]]`
**When** `is_allocation_feasible` is called
**Then** the function returns `False`

---

If you want, I can turn these directly into:
‚úÖ pytest test cases
‚úÖ Gherkin (`.feature`) format
‚úÖ a test table
‚úÖ or match them exactly to your lab spec wording

Just say which format you need üòÑ
"
----------------------------------------------------------------------------------------------------
Prompt 4: "give constraints 6 and asumptions to problem"
LLM Response 2: "Got it ‚Äî you want **problem constraints** and **assumptions** (not tests). Here are **6 constraints** and **6 assumptions** for the *resource allocation feasibility* problem.

---

## ‚úÖ Constraints (rules the solution must enforce)

1. **Resource capacities must be non-negative numbers**
   Each resource in `resources` must have a capacity ‚â• 0 and be numeric (int or float).

2. **Request amounts must be non-negative numbers**
   Each requested amount must be ‚â• 0 and be numeric.

3. **All requested resources must exist in the resource pool**
   A request cannot ask for a resource that is not defined in `resources`.

4. **Total requested amount for each resource must not exceed its capacity**
   For every resource `r`:
   `sum(requests[i][r]) ‚â§ resources[r]`

5. **Each request must be represented as a dictionary**
   Every element in `requests` must map resource names to amounts.

6. **The allocation decision is all-or-nothing**
   Either all requests are feasible together or the allocation is rejected (no partial allocation).

---

## üìå Assumptions (things we assume about the problem environment)

1. **Resources are independent of each other**
   CPU, RAM, disk, etc. do not affect each other‚Äôs capacity.

2. **Requests are additive**
   Resource usage is cumulative across all requests.

3. **No prioritization or ordering of requests**
   All requests are treated equally; order does not matter.

4. **No preemption or sharing logic**
   A resource unit cannot be partially reclaimed or dynamically adjusted once counted.

5. **No time dimension is considered**
   Requests are assumed to occur simultaneously (no scheduling over time).

6. **Units of measurement are consistent**
   All values for a given resource use the same unit (e.g., GB of RAM, number of CPUs).

---

If you want, I can rewrite these in:
‚úÖ more formal academic wording
‚úÖ simpler student-friendly wording
‚úÖ align them to IEEE-style requirement language
‚úÖ or match them to your lab handout format

Just say which style you want.
"